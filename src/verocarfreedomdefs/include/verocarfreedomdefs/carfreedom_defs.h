
#ifndef VERO_CARFREEDOM_DEFS_H
#define VERO_CARFREEDOM_DEFS_H

#include <string>
#include "ros/ros.h"
#include "candriver.h"
#include "carfreedom.h"
#include <verocarfreedomdefs_msgs/CarData.h>

namespace verocarfreedomdefs
{

//! -----------  MAX CAPABILITIES
/// these hardcoded constaints limit the values accepted for commands.
/// you can overide them with .cfg options
#define CARFREEDOM_MAX_SPEED_FORWARD_M_S 10
#define CARFREEDOM_MAX_SPEED_REVERSE_M_S 10
#define CARFREEDOM_MAX_STEERING_ANGLE_DEG 25
#define CARFREEDOM_MAX_STEERING_ANGLE_AT_MAX_SPEED_DEG 20

#define CARFREEDOM_MAX_JOYSTICK_FORWARD 1023
#define CARFREEDOM_MAX_JOYSTICK_REVERSE 0
#define CARFREEDOM_MAX_JOYSTICK_LEFT 0
#define CARFREEDOM_MAX_JOYSTICK_RIGHT 1023

#define CARFREEDOM_MAX_RIGHT_STEERING_ENCODER 1539
#define CARFREEDOM_MAX_LEFT_STEERING_ENCODER 2141
//! vehicle geometry in METERS (needed to calculate odometry)
#define CARFREEDOM_WHEEL_RADIUS_M 0.335
#define CARFREEDOM_INTER_AXES_DISTANCE_M 1.39
#define CARFREEDOM_AXIS_LENGTH_M 1.15
//! encoder specification - also needed for odometry
#define CARFREEDOM_PULSES_PER_360 8192
#define CARFREEDOM_VUNC 0.2

#define CARFREEDOM_PI 3.14159265358979323846
#define CARFREEDOM_DEG2RAD (CARFREEDOM_PI/180.0)

/**
 * \brief all functions which decode CAN frames may return these values when what they get is not what they expect
 */
enum CAN_decode_error {
  CANFRAME_OK,
  CANFRAME_BADID,
  CANFRAME_BADLENGTH,
  CANFRAME_BADDATA
};

//!------------------- MESSAGE ID'S

//! ------ SUPERVISOR
#define ID_QUERY_SUPERVISOR 0x80
#define ID_CMD_SUPERVISOR 0x81
#define ID_DATA_SUPERVISOR 0x100

//! ------ MOTOR DRIVERS
#define ID_DEFAULT_BASE_MOTOR_LEFT 0x08
#define ID_DEFAULT_BASE_MOTOR_RIGHT 0x00
#define ID_CMD_MOTOR_LEFT ID_DEFAULT_BASE_MOTOR_LEFT
#define ID_CMD_MOTOR_RIGHT ID_DEFAULT_BASE_MOTOR_RIGHT
#define ID_CMD_MOTOR_LEFT_RAW (ID_DEFAULT_BASE_MOTOR_LEFT+1)
#define ID_CMD_MOTOR_RIGHT_RAW (ID_DEFAULT_BASE_MOTOR_RIGHT+1)
#define ID_QUERY_MOTOR_LEFT (ID_DEFAULT_BASE_MOTOR_LEFT+2)
#define ID_QUERY_MOTOR_RIGHT (ID_DEFAULT_BASE_MOTOR_RIGHT+2)
#define ID_CFG_MOTOR_LEFT (ID_DEFAULT_BASE_MOTOR_LEFT+3)
#define ID_CFG_MOTOR_RIGHT (ID_DEFAULT_BASE_MOTOR_RIGHT+3)
#define ID_NEWID_MOTOR_LEFT (ID_DEFAULT_BASE_MOTOR_LEFT+4)
#define ID_NEWID_MOTOR_RIGHT (ID_DEFAULT_BASE_MOTOR_RIGHT+4)
#define ID_DATA_MOTOR_LEFT (ID_DEFAULT_BASE_MOTOR_LEFT+0x102)
#define ID_DATA_MOTOR_RIGHT (ID_DEFAULT_BASE_MOTOR_RIGHT+0x102)
/// ID_CMD_MOTOR_JOYSTICK is generated by the joystick (freedom supervisor box), and it is used by the PIC
#define ID_CMD_MOTOR_JOYSTICK 0x250
#define ID_CMD_MOTOR_RPH 0x251


//! -------- STEERING CTRL
#define ID_CMD_STEERING 0x10
#define ID_QUERY_STEERING_CTRL 0x13
#define ID_CMD_STEERING_RAW 0x14
#define ID_DATA_STEERING_CTRL 0x101
#define ID_HEARTBEAT_STEERING 0x141

//! ------- STEERING ENCODER
#define ID_QUERY_STEERING_ENCODER 0x20
#define ID_DATA_STEERING_ENCODER 0x12

//--------- MOTOR ENCODERS
#define ID_QUERY_ENCODER_REAR_RIGHT 0x40
#define ID_QUERY_ENCODER_REAR_LEFT 0x41
#define ID_QUERY_ENCODER_FRONT_RIGHT 0x42
#define ID_QUERY_ENCODER_FRONT_LEFT 0x43
#define ID_DATA_ENCODER_REAR_RIGHT 0x104
#define ID_DATA_ENCODER_REAR_LEFT 0x105
#define ID_DATA_ENCODER_FRONT_RIGHT 0x106
#define ID_DATA_ENCODER_FRONT_LEFT 0x107
#define ID_CFG_ENCODER_PERIOD_REAR_RIGHT 0x204
#define ID_CFG_ENCODER_PERIOD_REAR_LEFT 0x205
#define ID_CFG_ENCODER_PERIOD_FRONT_RIGHT 0x206
#define ID_CFG_ENCODER_PERIOD_FRONT_LEFT 0x207
#define ID_DATA_ENCODER_PULSES_REAR_RIGHT 0x200
#define ID_DATA_ENCODER_PULSES_REAR_LEFT 0x201
#define ID_DATA_ENCODER_PULSES_FRONT_RIGHT 0x202
#define ID_DATA_ENCODER_PULSES_FRONT_LEFT 0x203

//-------- GENERAL DATA
#define ID_DATA_CORRENTE_POTENCIA 0x210
#define ID_DATA_BATERIA 0x211

// -- for convenience, here is the definition of a can frame
// 32 bit CAN_ID + EFF/RTR/ERR flags
//      __u8    can_dlc; // data length code: 0 .. 8
//      __u8    data[8]


void fill_empty_canframe(struct can_frame &f, unsigned int ID);

/// -------------- functions to decode received can frames
CAN_decode_error extractSupervisorFrame(struct can_frame &frame,verocarfreedomdefs_msgs::CarData &data) ;
CAN_decode_error extractDataMotorFrame(struct can_frame &frame,verocarfreedomdefs_msgs::CarData &data) ;
CAN_decode_error extractDataSteeringCtrlFrame(struct can_frame &frame,verocarfreedomdefs_msgs::CarData &data) ;
CAN_decode_error extractDataSteeringEncoderFrame(struct can_frame &frame,
						  verocarfreedomdefs_msgs::CarData &data);
CAN_decode_error extractDataMotorEncoderFrame(struct can_frame &frame,verocarfreedomdefs_msgs::CarData &data);
CAN_decode_error extractDataMotorEncoderPulsesFrame(struct can_frame &frame, unsigned char &counter,
						     unsigned char &enc_err,
						    verocarfreedomdefs_msgs::CarData &data);
CAN_decode_error extractDataMotorEncoderPulsesFrame(struct can_frame &frame,unsigned char &counter,
						     unsigned char &enc_err,unsigned int &pulses);
CAN_decode_error extractDataMotorEncoderPulsesFrame(struct can_frame &frame, unsigned char &counter,
						     unsigned char &enc_err,
						    verocarfreedomdefs_msgs::CarData &data);
CAN_decode_error extractDataMotorEncoderPulsesFrame(struct can_frame &frame, unsigned char &counter,
						    verocarfreedomdefs_msgs::CarData &data);
CAN_decode_error extractDataMotorEncoderPulsesFrame(struct can_frame &frame,unsigned char &counter,
						     unsigned char &enc_err,unsigned int &pulses);
CAN_decode_error extractDataMotorEncoderPulsesFrame(struct can_frame &frame,unsigned char &counter,
						    unsigned int &pulses);
CAN_decode_error extractJoystickDataSpeed (struct can_frame frame, int &speed);
CAN_decode_error extractJoystickDataAngle (struct can_frame frame, int &angle);
CAN_decode_error extractCorrentePotenciaData (struct can_frame frame, verocarfreedomdefs_msgs::CarData &data_);
CAN_decode_error extractBateriaData (struct can_frame frame, verocarfreedomdefs_msgs::CarData &data_);

						    /// --------- functions to fill can frames to be sent to the car

int fill_supervisor_cmd(struct can_frame &frame,char modo, char light, char buz);
//----  motor drv commands
int fill_motordrv_cmd(unsigned int id,struct can_frame &frame,unsigned int cmd, char ch_brk, char status=0, char ch_liga=1);
int fill_motordrv_cmd_right(struct can_frame &frame,unsigned int cmd, char ch_brk, char status=0, char ch_liga=1);
int fill_motordrv_cmd_left(struct can_frame &frame,unsigned int cmd, char ch_brk, char status=0, char ch_liga=1);
//--- motor higher level rph (rotation per hour) command (one can frame for both motors) ---
int fill_motordrv_cmd_rph(struct can_frame &frame, unsigned int rph_r, unsigned int rph_l);
//--- motor higher level rph (rotation per hour) command (rpm forward - the car will calculate the differential) ---
int fill_motordrv_cmd_rph(struct can_frame &frame, unsigned int rph_f);

int fill_motordrv_cfgAccel(unsigned int id,struct can_frame &frame,char accel);
int fill_motordrv_cfgAccel_left(struct can_frame &frame,char accel);
int fill_motordrv_cfgAccel_right(struct can_frame &frame,char accel);

int fill_encoder_cfg(unsigned int id,struct can_frame &frame,unsigned char period);
int fill_encoder_cfg_rear_right(struct can_frame &frame,unsigned char period);
int fill_encoder_cfg_rear_left(struct can_frame &frame,unsigned char period);
int fill_encoder_cfg_front_right(struct can_frame &frame,unsigned char period);
int fill_encoder_cfg_front_left(struct can_frame &frame,unsigned char period);
//----------
int fill_steering_cmd(struct can_frame &frame,unsigned int cmd, char ch_liga=0, char ch_brk=0);

/*
shamelessly copied from etheora_interpolate(a, b, x, c, d, y):
find a y value in the range c..d equivalent to
a x value in the range a..b

example: given a temperature X Celsius degree,
ie, a..b = 0..100, find the temperature y Farenheit degree,
ie, c..d = 32..180.

etheora_interpolate(0, 100, X, 32, 180, y);

TODO: these functions may result inexact values. the caller
must ensure these values are in the desired range.

*/
#define interpolate(a, b, x, c, d, y)  \
        y = (float)((float)x-(float)a)*((float)d-(float)c)/((float)b-(float)a) + c;  \
        if((y < c)&&(y < d)) y = (c<d)?c:d; \
        if((y > d)&&(y > c)) y = (d>c)?d:c;



}// namespace

#endif





